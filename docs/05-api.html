<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"><title>NuclearJS | API</title><link href="https://optimizely.github.io/nuclear-js/assets/css/output.css" type="text/css" rel="stylesheet" media="screen,projection"><script src="//cdn.optimizely.com/js/3006700484.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-64060472-1', 'auto');
ga('send', 'pageview');</script></head><body><div class="navbar-fixed"><nav class="nav"><div class="nav-wrapper"><a href="https://optimizely.github.io/nuclear-js/">NuclearJS</a><ul id="nav-mobile" class="right hide-on-med-and-down"><li><a href="https://optimizely.github.io/nuclear-js/docs/01-getting-started.html">Docs</a></li><li><a href="https://optimizely.github.io/nuclear-js/docs/05-api.html">API</a></li><li><a href="https://github.com/optimizely/nuclear-js">Github</a></li></ul></div></nav></div><div class="container"><div class="docs-page row"><div class="docs-page--sidebar col l2"><h3>Docs</h3><ul class="sidebar-links"><li class="sidebar-links--item"><a href="https://optimizely.github.io/nuclear-js/docs/01-getting-started.html">Getting Started</a></li><li class="sidebar-links--item"><a href="https://optimizely.github.io/nuclear-js/docs/02-getters.html">Getters</a></li><li class="sidebar-links--item"><a href="https://optimizely.github.io/nuclear-js/docs/03-hooking-up-to-react.html">Hooking up to React</a></li><li class="sidebar-links--item"><a href="https://optimizely.github.io/nuclear-js/docs/04-async-actions-and-optimistic-updates.html">Async Actions and Optimistic Updates</a></li><li class="sidebar-links--item"><a href="https://optimizely.github.io/nuclear-js/docs/05-api.html">API</a></li></ul></div><div class="docs-page--contents col l8"><h1 id="api-documentation">API Documentation</h1>
<h2 id="reactor">Reactor</h2>
<h3 id="-reactor-dispatch-messagetype-messagepayload-"><code>Reactor#dispatch(messageType, messagePayload)</code></h3>
<p>Dispatches a message to all registered Stores. This process is done synchronously, all registered <code>Store</code>s are passed this message and all components are re-evaluated (efficiently).  After a dispatch, a Reactor will emit the new state on the <code>reactor.changeEmitter</code></p>
<p>ex: <code>reactor.dispatch(&#39;addUser&#39;, { name: &#39;jordan&#39; })</code></p>
<h3 id="-reactor-evaluate-getter-keypath-"><code>Reactor#evaluate(Getter | KeyPath)</code></h3>
<p>Returns the immutable value for some KeyPath or Getter in the reactor state. Returns <code>undefined</code> if a keyPath doesn&#39;t have a value.</p>
<pre><code class="lang-javascript">reactor.evaluate([&#39;users&#39;, &#39;active&#39;])
reactor.evaluate([
  [&#39;users&#39;, &#39;active&#39;],
  [&#39;filters&#39;, &#39;username&#39;],
  /**
   * @param {Immutable.List} activeUsers
   * @param {String} usernameFilter
   * @return {Immutable.List}
   */
  function(activeUsers, usernameFilter) {
    return activeUsers.filter(function(user) {
      return user.get(&#39;username&#39;).indexOf(usernameFilter) !== -1
    }
  },
])
</code></pre>
<h3 id="-reactor-evaluatetojs-keypath-transformfn-"><code>Reactor#evaluateToJS(...keyPath, [transformFn])</code></h3>
<p>Same as <code>evaluate</code> but coerces the value to a plain JS before returning</p>
<h3 id="-reactor-observe-keypathorgetter-handlerfn-"><code>Reactor#observe(keyPathOrGetter, handlerFn)</code></h3>
<p>Takes a getter or keyPath and calls the handlerFn with the evaluated value whenever the getter or keyPath changes.</p>
<p><strong>Note</strong>:  You cannot call <code>flux.dispatch</code> within the handle function of a <code>flux.observe</code>.  This violates one of the fundamental design patterns in Flux architecture, which forbids cascading dispatches on the system which cause highly unpredictive systems.</p>
<pre><code class="lang-javascript">reactor.observe([
  [&#39;items&#39;]
  function(items) {
    console.log(&#39;items changed&#39;);
  }
])
</code></pre>
<h3 id="-reactor-registerstores-stores-"><code>Reactor#registerStores(stores)</code></h3>
<p><code>stores</code> - an object of storeId =&gt; store instance</p>
<pre><code class="lang-javascript">reactor.registerStores({
  &#39;threads&#39;: require(&#39;./stores/thread-store&#39;),
  &#39;currentThreadID&#39;: require(&#39;./stores/current-thread-id-store&#39;),
})
</code></pre>
<h3 id="-reactor-reset-"><code>Reactor#reset()</code></h3>
<p>Causes all stores to be reset to their initial state.  Extremely useful for testing, just put a <code>reactor.reset()</code> call in your <code>afterEach</code> blocks.</p>
<h3 id="-reactor-reactmixin-"><code>Reactor#ReactMixin</code></h3>
<p>Exposes the ReactMixin to do automatic data binding.</p>
<pre><code class="lang-javascript">var ThreadSection = React.createClass({
  mixins: [flux.ReactMixin],

  getDataBindings() {
    return {
      threads: Chat.getters.threads,
      unreadCount: Chat.getters.unreadCount,
      currentThreadID: Chat.getters.currentThreadID,
    }
  },

  render: function() {
    var threadListItems = this.state.threads.map(thread =&gt; {
      return (
        &lt;ThreadListItem
          key={thread.get(&#39;threadID&#39;)}
          thread={thread}
          currentThreadID={this.state.currentThreadID}
        /&gt;
      );
    }, this);
    var unread =
      this.state.unreadCount === 0 ?
      null :
      &lt;span&gt;Unread threads: {this.state.unreadCount}&lt;/span&gt;;
    return (
      &lt;div className=&quot;thread-section&quot;&gt;
        &lt;div className=&quot;thread-count&quot;&gt;
          {unread}
        &lt;/div&gt;
        &lt;ul className=&quot;thread-list&quot;&gt;
          {threadListItems}
          &lt;/ul&gt;
      &lt;/div&gt;
    );
  },
});
</code></pre>
<h2 id="constructors">Constructors</h2>
<h3 id="-nuclear-reactor-"><code>Nuclear.Reactor</code></h3>
<pre><code class="lang-javascript">var reactor = new Nuclear.Reactor(config)
</code></pre>
<p><strong>Configuration Options</strong></p>
<p><code>config.debug</code> Boolean - if true it will log the entire app state for every dispatch.</p>
<h3 id="-nuclear-store-"><code>Nuclear.Store</code></h3>
<pre><code class="lang-javascript">module.exports = new Nuclear.Store({
  getInitialState: function() {
    // method must return an immutable value for NuclearJS to take advantage of efficient equality checks
    return toImmutable({})
  },

  initialize: function() {
    // sets up action handlers via `this.on`
    this.on(&#39;SOME_ACTION&#39;, function(state, payload) {
      // action handler takes state + payload and returns new state
    })
  },
})
</code></pre>
<h2 id="utilities">Utilities</h2>
<p>NuclearJS comes with several utility functions that are exposed on the <code>Nuclear</code> variable.</p>
<h3 id="-nuclear-immutable-"><code>Nuclear.Immutable</code></h3>
<p>Provides access to the ImmutableJS <code>Immutable</code> object.</p>
<h3 id="-nuclear-toimmutable-value-"><code>Nuclear.toImmutable(value)</code></h3>
<p>Coerces a value to its immutable counterpart, can be called on any type safely.  It will convert Objects to <code>Immutable.Map</code> and Arrays to <code>Immutable.List</code></p>
<h3 id="-nuclear-tojs-value-"><code>Nuclear.toJS(value)</code></h3>
<p>Will coerce an Immutable value to its mutable counterpart.  Can be called on non-immutable values safely.</p>
<h3 id="-nuclear-isimmutable-value-boolean"><code>Nuclear.isImmutable(value)</code> : Boolean</h3>
<p>Returns true if the value is an ImmutableJS data structure.</p>
<h3 id="-nuclear-iskeypath-value-boolean"><code>Nuclear.isKeyPath(value)</code> : Boolean</h3>
<p>Returns true if the value is the format of a valid keyPath</p>
<h3 id="-nuclear-isgetter-value-boolean"><code>Nuclear.isGetter(value)</code> : Boolean</h3>
<p>Returns true if the value is the format of a valid getter</p>
</div></div></div><script src="https://optimizely.github.io/nuclear-js/app.js"></script></body></html>